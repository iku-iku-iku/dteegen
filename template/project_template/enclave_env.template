path: z_enclave_env_provider.cpp
#include "${project}_u.h"
#include "enclave.h"
#include <linux/limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <TEE-Capability/distributed_tee.h>

cc_enclave_t g_enclave;
cc_enclave_t *g_enclave_context;

extern "C" {

static bool is_migrate() {
  if (g_current_dtee_context) {
    if (g_current_dtee_context->config.side == SIDE::Client && 
        g_current_dtee_context->config.mode == MODE::MIGRATE) {
      return true;
    }
  }
  return false;
}

// 迁移模式下，远程调用enclave
struct cc_enclave_ops migrate_enclave_ops = {
  .cc_ecall_enclave = (decltype(std::declval<cc_enclave_ops>().cc_ecall_enclave))remote_ecall_enclave
};

struct cc_enclave_ops_desc migrate_enclave_desc = {
  .ops = &migrate_enclave_ops
};

struct list_ops_desc migrate_enclave_list_ops_desc = {
  .ops_desc = &migrate_enclave_desc
};

cc_enclave_t migrate_enclave = {
  .list_ops_node = &migrate_enclave_list_ops_desc
};

void z_create_enclave(const char* enclave_path) {
  if (is_migrate()) {
    // 如果是迁移模式，那么直接使用静态创建的enclave
    g_enclave_context = &migrate_enclave;
    return;
  } else {
    g_enclave_context = &g_enclave;
  }

  cc_enclave_result_t res = CC_FAIL;

  // char *path = PATH;
  //
  // char real_p[PATH_MAX];
  // /* check file exists, if not exist then use absolute path */
  // if (realpath(path, real_p) == NULL) {
  //   if (getcwd(real_p, sizeof(real_p)) == NULL) {
  //     printf("Cannot find enclave.sign.so");
  //     goto end;
  //   }
  //   if (PATH_MAX - strlen(real_p) <= strlen("/enclave.signed.so")) {
  //     printf("Failed to strcat enclave.sign.so path");
  //     goto end;
  //   }
  //   (void)strcat(real_p, "/enclave.signed.so");
  // }

  res = cc_enclave_create(enclave_path, AUTO_ENCLAVE_TYPE, 0, SECGEAR_DEBUG_FLAG,
                          NULL, 0, g_enclave_context);
  if (res != CC_SUCCESS) {
    printf("Create enclave error\n");
    goto end;
  }

  return;

end:
  exit(-1);
}

void z_destroy_enclave() {
  if (is_migrate()) {
    return;
  }
  if (g_enclave_context == &g_enclave) {
    cc_enclave_result_t res = cc_enclave_destroy(g_enclave_context);
    if (res != CC_SUCCESS) {
      printf("Destroy enclave error\n");
    }
    g_enclave_context = NULL;
  }
}

__attribute__((constructor)) void before_main() {
  pthread_rwlock_init(&(migrate_enclave.rwlock), NULL);
 // g_enclave = (cc_enclave_t *)malloc(sizeof(cc_enclave_t));
 // if (!g_enclave) {
 //   // return CC_ERROR_OUT_OF_MEMORY;
 //   printf("Create g_enclave error\n");
 //   return;
 // }
 // memset(g_enclave, 0, sizeof(*g_enclave));
 // // z_create_enclave();
}


int ecall_proxy(const char* enclave_filename, uint32_t fid, char* in_buf, int in_buf_size, char* out_buf, int out_buf_size) {
  z_create_enclave(enclave_filename);
  cc_enclave_result_t ret = CC_FAIL;
  uint32_t ms = 0;

  /* Call the cc_enclave function */
  cc_enclave_t* enclave = g_enclave_context;
  if (!enclave) {
      ret = CC_ERROR_BAD_PARAMETERS;
      goto exit;
  }
  if (pthread_rwlock_rdlock(&enclave->rwlock)) {
      ret = CC_ERROR_BUSY;
      goto exit;
  }
  if (!enclave->list_ops_node || !enclave->list_ops_node->ops_desc ||
            !enclave->list_ops_node->ops_desc->ops ||
            !enclave->list_ops_node->ops_desc->ops->cc_ecall_enclave) {
      ret = CC_ERROR_BAD_PARAMETERS;
      goto exit;
  }
  if ((ret = enclave->list_ops_node->ops_desc->ops->cc_ecall_enclave(
            enclave,
            fid,
            in_buf,
            in_buf_size,
            out_buf,
            out_buf_size,
            &ms,
            NULL)) != CC_SUCCESS) {
      pthread_rwlock_unlock(&enclave->rwlock);
      goto exit; }
  if (pthread_rwlock_unlock(&enclave->rwlock)) {
      ret = CC_ERROR_BUSY;
      goto exit;
  }
  
  ret = CC_SUCCESS;

exit:
  z_destroy_enclave();
  return ret;
}
}


